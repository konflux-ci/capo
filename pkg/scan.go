package capo

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path"
	"regexp"

	"capo/internal/sbom"

	"go.podman.io/storage"
	"go.podman.io/storage/pkg/reexec"
)

type StageScanResult struct {
	Alias    string `json:"alias,omitempty"`
	Pullspec string `json:"pullspec"`
	// absolute path to the partial intermediate layer SBOM for this image
	// if it's not present or is empty, the image doesn't have any intermediate layer
	IntermediateSBOM string `json:"intermediate_sbom,omitempty"`
	// absolute path to the partial builder layer SBOM for this image
	BuilderSBOM string `json:"builder_sbom"`
}

type ScanResult struct {
	Stages []StageScanResult `json:"stages"`
}

// Print the ScanResult to stdout as JSON
func (sr ScanResult) Print() {
	var buf bytes.Buffer

	encoder := json.NewEncoder(&buf)
	encoder.SetIndent("", "  ")
	encoder.Encode(sr)

	fmt.Println(buf.String())
}

func setupStore() (storage.Store, error) {
	// The containers/storage library requires this to run for some operations
	if reexec.Init() {
		return nil, fmt.Errorf("Failed to init reexec during containers/storage setup.")
	}

	opts, err := storage.DefaultStoreOptions()
	if err != nil {
		return nil, fmt.Errorf("Failed to create default container/storage options.")
	}

	store, err := storage.GetStore(opts)
	if err != nil {
		return nil, fmt.Errorf("Failed to create default container/storage store.")
	}

	return store, nil
}

/*
Scans passed stages and returns a ScanResult struct, that contains
paths to SBOMs for the stages' builder and intermediate content
generated by Syft.

The paths in the ScanResult struct include the output directory as a prefix.
*/
func Scan(
	stages []Stage,
	output string,
) (ScanResult, error) {
	store, err := setupStore()
	if err != nil {
		return ScanResult{}, err
	}

	if err := os.MkdirAll(output, 0755); err != nil {
		return ScanResult{}, err
	}

	stageResults := make([]StageScanResult, 0)
	for _, stage := range stages {
		res, err := scanStage(store, stage, output)
		if err != nil {
			return ScanResult{}, fmt.Errorf("Failed to scan stage %+v with error: %v.", stage, err)
		}

		stageResults = append(stageResults, res)
	}

	return ScanResult{
		Stages: stageResults,
	}, nil
}

func scanStage(store storage.Store, stage Stage, output string) (res StageScanResult, err error) {
	builderContentPath, err := os.MkdirTemp("", "")
	if err != nil {
		return res, err
	}

	intermediateContentPath, err := os.MkdirTemp("", "")
	if err != nil {
		return res, err
	}

	// if in debug mode, print the paths to saved content
	// and don't remove the temporary directories
	debugMode := os.Getenv("CAPO_DEBUG") != ""
	if debugMode {
		log.Printf("[DEBUG] Builder content path: %s", builderContentPath)
		log.Printf("[DEBUG] Intermediate content path: %s", intermediateContentPath)
	} else {
		defer os.RemoveAll(builderContentPath)
		defer os.RemoveAll(intermediateContentPath)
	}

	err = getContent(store, stage, builderContentPath, intermediateContentPath)
	if err != nil {
		return res, err
	}

	log.Printf("Builder \"%s\" intermediate diff path: %s", stage.Pullspec(), intermediateContentPath)
	iSbomFilename := sanitizePullspec(stage.Pullspec()) + "-intermediate.json"
	iSbomPath := path.Join(output, iSbomFilename)
	if err := sbom.SyftScan(intermediateContentPath, iSbomPath); err != nil {
		return res, err
	}

	bSbomFilename := sanitizePullspec(stage.Pullspec()) + "-builder.json"
	bSbomPath := path.Join(output, bSbomFilename)
	log.Printf("Builder \"%s\" content path: %s", stage.Pullspec(), builderContentPath)
	if err := sbom.SyftScan(builderContentPath, bSbomPath); err != nil {
		return res, err
	}

	return StageScanResult{
		Alias:            stage.Alias(),
		Pullspec:         stage.Pullspec(),
		IntermediateSBOM: iSbomPath,
		BuilderSBOM:      bSbomPath,
	}, nil
}

// Sanitize a pullspec so it can be used as a file path
func sanitizePullspec(pullspec string) string {
	// replace invalid filesystem characters with underscores
	invalidChars := regexp.MustCompile(`[/\\:*?"<>|]`)
	result := invalidChars.ReplaceAllString(pullspec, "_")

	// replace consecutive underscores with single underscore
	result = regexp.MustCompile(`_+`).ReplaceAllString(result, "_")

	return result
}
