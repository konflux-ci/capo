package capo

import (
	"fmt"
	"log"
	"os"

	"capo/internal/sbom"

	"go.podman.io/storage"
	"go.podman.io/storage/pkg/reexec"
)

type PackageMetadata struct {
	Packages []PackageMetadataItem `json:"packages"`
}

type PackageMetadataItem struct {
	PackageURL string `json:"purl"`

	// Slice of checksums, with checksum type prefixed (e.g. "sha256:deadbeef").
	// Omitted if syft didn't provide any checksums.
	Checksums []string `json:"checksums,omitempty"`

	// PURL of the package that this package is a dependency of.
	DependencyOfPURL string `json:"dependency_of_purl,omitempty"`

	// Type of origin of this package, can be "builder" or "intermediate".
	OriginType string `json:"origin_type"`

	// Pullspec of the image which is this package's origin.
	Pullspec string `json:"pullspec"`

	// Alias of the stage of this package's origin.
	// Omitted if this package is from an external image.
	StageAlias string `json:"stage_alias,omitempty"`
}

func setupStore() (storage.Store, error) {
	// The containers/storage library requires this to run for some operations
	if reexec.Init() {
		return nil, fmt.Errorf("Failed to init reexec during containers/storage setup.")
	}

	opts, err := storage.DefaultStoreOptions()
	if err != nil {
		return nil, fmt.Errorf("Failed to create default container/storage options.")
	}

	store, err := storage.GetStore(opts)
	if err != nil {
		return nil, fmt.Errorf("Failed to create default container/storage store.")
	}

	return store, nil
}

/*
Scans passed stages and returns a ScanResult struct, that contains
paths to SBOMs for the stages' builder and intermediate content
generated by Syft.

The paths in the ScanResult struct include the output directory as a prefix.
*/
func Scan(
	stages []Stage,
) (res PackageMetadata, err error) {
	store, err := setupStore()
	if err != nil {
		return PackageMetadata{}, err
	}

	for _, stage := range stages {
		stagePkgItems, err := scanStage(store, stage)
		if err != nil {
			return PackageMetadata{}, fmt.Errorf("Failed to scan stage %+v with error: %v.", stage, err)
		}

		res.Packages = append(res.Packages, stagePkgItems...)
	}

	return res, nil
}

func scanStage(store storage.Store, stage Stage) (res []PackageMetadataItem, err error) {
	builderContentPath, err := os.MkdirTemp("", "")
	if err != nil {
		return res, err
	}

	intermediateContentPath, err := os.MkdirTemp("", "")
	if err != nil {
		return res, err
	}

	// if in debug mode, print the paths to saved content
	// and don't remove the temporary directories
	debugMode := os.Getenv("CAPO_DEBUG") != ""
	if debugMode {
		log.Printf("[DEBUG] Builder %s content path: %s", stage.Pullspec(), builderContentPath)
		log.Printf("[DEBUG] Intermediate %s content path: %s", stage.Pullspec(), intermediateContentPath)
	} else {
		defer os.RemoveAll(builderContentPath)
		defer os.RemoveAll(intermediateContentPath)
	}

	err = getContent(store, stage, builderContentPath, intermediateContentPath)
	if err != nil {
		return res, err
	}

	intermediatePkgs, err := sbom.SyftScan(intermediateContentPath)
	if err != nil {
		return res, err
	}

	builderPkgs, err := sbom.SyftScan(builderContentPath)
	if err != nil {
		return res, err
	}

	return getPackageMetadata(stage, builderPkgs, intermediatePkgs), nil
}

func getPackageMetadata(
	stage Stage,
	builderPkgs []sbom.SyftPackage,
	intermediatePkgs []sbom.SyftPackage,
) (res []PackageMetadataItem) {
	for _, bpkg := range builderPkgs {
		res = append(res, PackageMetadataItem{
			Pullspec:         stage.Pullspec(),
			StageAlias:       stage.Alias(),
			PackageURL:       bpkg.PURL,
			DependencyOfPURL: bpkg.DependencyOfPURL,
			Checksums:        bpkg.Checksums,
			OriginType:       "builder",
		})
	}

	for _, ipkg := range intermediatePkgs {
		res = append(res, PackageMetadataItem{
			Pullspec:         stage.Pullspec(),
			StageAlias:       stage.Alias(),
			PackageURL:       ipkg.PURL,
			DependencyOfPURL: ipkg.DependencyOfPURL,
			Checksums:        ipkg.Checksums,
			OriginType:       "intermediate",
		})
	}

	return res
}
