package capo

import (
	"log"
	"os"
	"path"
	"regexp"

	"capo/internal/sbom"
	"capo/pkg/content"
	"capo/pkg/includer"

	"go.podman.io/storage"
)

/*
Returns a BuilderScanResult instance, that contains paths to SBOMs
for the specified builder's builder content and intermediate content
generated by Syft.

Only syft scans content that needs to be included based on the includer.

Creates a subdirectory in the output directory with the name of the builder's alias.
It then scans the content and stores the respective SBOMs to the subdirectory. All paths are
saved in the returned BuilderScanResult struct.
Example paths: (output/builder/builder.alias/builder.json and output/builder/builder.alias/intermediate.json)

Users should use the paths in the returned struct to access the SBOMs.
*/
func ScanBuilder(
	store storage.Store,
	builderStage includer.StageData,
	includer includer.Includer,
	output string,
) (BuilderScanResult, error) {
	dest := path.Join(output, "builder", builderStage.Alias())
	if err := os.MkdirAll(dest, 0755); err != nil {
		return BuilderScanResult{}, err
	}

	builderContentPath, err := os.MkdirTemp("", "")
	if err != nil {
		return BuilderScanResult{}, err
	}
	defer os.RemoveAll(builderContentPath)
	intermediateContentPath, err := os.MkdirTemp("", "")
	if err != nil {
		return BuilderScanResult{}, err
	}
	defer os.RemoveAll(builderContentPath)

	err = content.GetBuilderContent(store, builderStage.Pullspec(), includer, builderContentPath, intermediateContentPath)
	if err != nil {
		return BuilderScanResult{}, err
	}

	log.Printf("Builder \"%s\" intermediate diff path: %s", builderStage.Alias(), intermediateContentPath)
	iSbomPath := path.Join(dest, "intermediate.json")
	if err := sbom.SyftScan(intermediateContentPath, iSbomPath); err != nil {
		return BuilderScanResult{}, err
	}

	bSbomPath := path.Join(dest, "builder.json")
	log.Printf("Builder \"%s\" content path: %s", builderStage.Alias(), builderContentPath)
	if err := sbom.SyftScan(builderContentPath, bSbomPath); err != nil {
		return BuilderScanResult{}, err
	}

	return BuilderScanResult{
		Pullspec:         builderStage.Pullspec(),
		IntermediateSBOM: iSbomPath,
		BuilderSBOM:      bSbomPath,
	}, nil
}

func ScanExternal(
	store storage.Store,
	externalStage includer.StageData,
	includer includer.Includer,
	output string,
) (ExternalScanResult, error) {
	dest := path.Join(output, "external")
	if err := os.MkdirAll(dest, 0755); err != nil {
		return ExternalScanResult{}, err
	}

	externalContentPath, err := os.MkdirTemp("", "")
	if err != nil {
		return ExternalScanResult{}, err
	}
	defer os.RemoveAll(externalContentPath)

	err = content.GetExternalContent(
		store, externalStage.Pullspec(), includer, externalContentPath,
	)
	if err != nil {
		return ExternalScanResult{}, err
	}

	eSbomPath := path.Join(dest, sanitizePullspec(externalStage.Pullspec())+".json")
	log.Printf("External \"%s\" content path: %s", externalStage.Pullspec(), externalContentPath)
	if err := sbom.SyftScan(externalContentPath, eSbomPath); err != nil {
		return ExternalScanResult{}, err
	}

	return ExternalScanResult{
		Pullspec: externalStage.Pullspec(),
		SBOM:     eSbomPath,
	}, nil
}

// Sanitize a pullspec so it can be used as a file path
func sanitizePullspec(pullspec string) string {
	// replace invalid filesystem characters with underscores
	invalidChars := regexp.MustCompile(`[/\\:*?"<>|]`)
	result := invalidChars.ReplaceAllString(pullspec, "_")

	// replace consecutive underscores with single underscore
	result = regexp.MustCompile(`_+`).ReplaceAllString(result, "_")

	return result
}
